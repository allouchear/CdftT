#include<iostream>
#include<iomanip>
#include<algorithm>
#include <Orbitals/Orbitals.h>
#include <Utils/LM.h>

using namespace std;


void Orbitals::Save(string& tag)
{
    if(tag.find(".wfx")!=string::npos)
        Save_wfx(tag);
    else if(tag.find(".molden")!=string::npos)
        Save_molden(tag);
    else if(tag.find(".gab")!=string::npos)
        Save_gab(tag);
    else
    {
        cout<<"Format not recognize, please choose a valide format"<<endl;
        exit(1);
    }
}

void Orbitals::Save_wfx(string& tag)
{
    int n, nMO;
    ofstream s;
    s.open(tag);

    s<<"<Title>"<<endl;
    s<<" Input file generated by cdftt..."<<endl;
    s<<"</Title>"<<endl;

    s<<"<Keywords>"<<endl;
    s<<" GTO"<<endl;
    s<<"</Keywords>"<<endl;

    s<<"<Number of Nuclei>"<<endl;
    s<<" "<<_numberOfAtoms<<endl;
    s<<"</Number of Nuclei>"<<endl;

    s<<"<Number of Occupied Molecular Orbitals>"<<endl;
    if(!_alphaAndBeta)
        nMO=_numberOfMo*2;
    else
        nMO=_numberOfMo;
    s<<" "<<nMO<<endl;
    s<<"</Number of Occupied Molecular Orbitals>"<<endl;

    s<<"<Number of Perturbations>"<<endl;
    s<<" 0"<<endl;
    s<<"</Number of Perturbations>"<<endl;

    s<<"<Net Charge>"<<endl;
    s<<" 0"<<endl;
    s<<"</Net Charge>"<<endl;

    s<<"<Number of Electrons>"<<endl;
    s<<" "<<_numberOfAlphaElectrons+_numberOfBetaElectrons<<endl;
    s<<"</Number of Electrons>"<<endl;

    s<<"<Number of Alpha Electrons>"<<endl;
    s<<" "<<_numberOfAlphaElectrons<<endl;
    s<<"</Number of Alpha Electrons>"<<endl;

    s<<"<Number of Beta Electrons>"<<endl;
    s<<" "<<_numberOfBetaElectrons<<endl;
    s<<"</Number of Beta Electrons>"<<endl;

    s<<"<Nuclear Names>"<<endl;
    for(int i=0; i<_numberOfAtoms; i++)
        s<<" "<<_symbol[i]<<i+1<<endl;
    s<<"</Nuclear Names>"<<endl;

    s<<"<Atomic Numbers>"<<endl;
    for(int i=0; i<_numberOfAtoms; i++)
        s<<" "<<_atomicNumbers[i]<<endl;
    s<<"</Atomic Numbers>"<<endl;    

    s<<"<Nuclear Charges>"<<endl;
    for(int i=0; i<_numberOfAtoms; i++)
        s<<right<<scientific<<setprecision(12)<<" "<<setw(20)<<double(_atomicNumbers[i])<<endl;
    s<<"</Nuclear Charges>"<<endl;

    s<<"<Nuclear Cartesian Coordinates>"<<endl;
    for(int i=0; i<_numberOfAtoms; i++)
    {
        for(int j=i*3; j<(i+1)*3; j++)
            s<<right<<scientific<<setprecision(12)<<" "<<setw(20)<<_coordinates[j];
        s<<endl;
    }
    s<<"</Nuclear Cartesian Coordinates>"<<endl;

    s<<"<Number of Primitives>"<<endl;
    s<<" "<<_numberOfGtf<<endl;
    s<<"</Number of Primitives>"<<endl;

    s<<"<Primitive Centers>"<<endl;

    if(int(_vcgtfNonNormalise.size())==_numberOfGtf)
        for(int i=0; i<_numberOfGtf; i++)
        {
            s<<"\t"<<_primitiveCenters[i];
            if((i+1)%5==0)
                s<<endl;
        }
    else
    {
        vector<int> pc;
        for(size_t i=0; i<_vcgtf.size(); i++)
            for(int j=0; j<_vcgtf[i].numberOfFunctions(); j++)
                pc.push_back(_vcgtf[i].NumCenter());

        for(int i=0; i<_numberOfGtf; i++)
        {
            s<<"\t"<<pc[i];
            if((i+1)%5==0)
                s<<endl;
        }
    }
    s<<endl;
    s<<"</Primitive Centers>"<<endl;

    n=0;
    s<<"<Primitive Types>"<<endl;
    for(size_t i=0; i<_vcgtf.size(); i++)
        for(int j=0; j<_vcgtf[i].numberOfFunctions(); j++)
        {
            s<<"\t"<<getwfxType(_vcgtf[i].gtf()[j].get_l());
            if((n+1)%5==0)
                s<<endl;
            n++;
        }
    s<<endl;
    s<<"</Primitive Types>"<<endl;

    n=0;
    s<<"<Primitive Exponents>"<<endl;
    for(size_t i=0; i<_vcgtf.size(); i++)
        for(int j=0; j<_vcgtf[i].numberOfFunctions(); j++)
        {
            s<<right<<scientific<<setprecision(12)<<"\t"<<setw(20)<<_vcgtf[i].gtf()[j].get_exponent();
            if((n+1)%5==0)
                s<<endl;
            n++;
        }
    s<<endl;
    s<<"</Primitive Exponents>"<<endl;

    int m;

    if(_alphaAndBeta)
        m=1;
    else
        m=2;

    s<<"<Molecular Orbital Occupation Numbers>"<<endl;
    for(int i=0; i<m; i++)
        for(int j=0; j<_numberOfMo; j++)
            s<<" "<<_occupationNumber[i][j]<<endl;
    s<<"</Molecular Orbital Occupation Numbers>"<<endl;

    s<<"<Molecular Orbital Energies>"<<endl;
    for(int i=0; i<m; i++)
        for(size_t j=0; j<_orbitalEnergy[i].size(); j++)
            s<<right<<scientific<<setprecision(12)<<" "<<setw(20)<<_orbitalEnergy[i][j]<<endl;
    s<<"</Molecular Orbital Energies>"<<endl;

    s<<"<Molecular Orbital Spin Types>"<<endl;
    if(m==1)
        for(int i=0; i<_numberOfMo; i++)
            s<<" "<<"Alpha and Beta"<<endl;
    else
    {
        for(size_t i=0; i<_orbitalEnergy[0].size(); i++)
            s<<" "<<"Alpha"<<endl;
        for(size_t i=0; i<_orbitalEnergy[1].size(); i++)
            s<<" "<<"Beta"<<endl;
    }
    s<<"</Molecular Orbital Spin Types>"<<endl;

    s<<"<Molecular Orbital Primitive Coefficients>"<<endl;
    int a=0,b=0;
    for(int i=0; i<m; i++)
        for(int j=0; j<_numberOfMo; j++)
        {
            a++;
            s<<"<MO Number>"<<endl;
            s<<" "<<a<<endl;
            s<<"</MO Number>"<<endl;
        
            for(size_t k=0; k<_vcgtf.size(); k++)
                for(int l=0; l<_vcgtf[k].numberOfFunctions(); l++)
                {
                    s<<right<<scientific<<setprecision(12)<<" "<<setw(20)<<_vcgtf[k].coefficients()[l]*_vcgtf[k].gtf()[l].get_coefficient()*_coefficients[i][j][k];

                    if((b+1)%4==0)
                        s<<endl;
                    b++;
                }

            if(b%4!=0)
                s<<endl;
        }
    s<<"</Molecular Orbital Primitive Coefficients>"<<endl;

    s<<"<Energy = T + Vne + Vee + Vnn>"<<endl;
    s<<" "<<_energy<<endl;
    s<<"</Energy = T + Vne + Vee + Vnn>"<<endl;

    s<<"<Virial Ratio (-V/T)>"<<endl;
    s<<" "<<scientific<<setprecision(12)<<2<<endl;
    s<<"</Virial Ratio (-V/T)>"<<endl;

    s.close();
}
                                                            // Moldengab faire attention au format sphe/cart !!!!
void Orbitals::Save_molden(string& tag)    
{
    if(int(_vcgtfNonNormalise.size())==_numberOfGtf)
    {
        cout<<"This option is nnot implemente."<<endl;
        return;
    }

    ofstream s;
    s.open(tag);

    s<<"[Molden Format]"<<endl;

    s<<"[Atoms] AU"<<endl;
    for(int i=0; i<_numberOfAtoms; i++)
    {
        s<<_symbol[i]<<" "<<i+1<<" "<<_atomicNumbers[i];
        for(int j=i*3; j<(i+1)*3; j++)
            s<<std::fixed<<setprecision(6)<<right<<"  "<<setw(10)<<_coordinates[j];
        s<<endl;
    }

    s<<endl;
    
    bool d=false, f=false, g=false;

    for(size_t i=0; i<_vcgtfNonNormalise.size(); i++)
    {
        if(_vcgtfNonNormalise[i].Lformat()=="Sphe")
        {
            if((_vcgtfNonNormalise[i].Ltype()=="D" || _vcgtfNonNormalise[i].Ltype()=="d") && !d)
            {
                s<<"[5D] ";
                d=true;
            }
            else if((_vcgtfNonNormalise[i].Ltype()=="F" || _vcgtfNonNormalise[i].Ltype()=="f") &&!f)
            {
                s<<"[7F] ";
                f=true;
            }
            else if((_vcgtfNonNormalise[i].Ltype()=="G" || _vcgtfNonNormalise[i].Ltype()=="d") && !g)
            {
                s<<"[9G] ";
                g=true;
            }
        }
    }

    s<<endl<<"[GTO]"<<endl;

    int lt,q,m,k=0;
    double save_alpha;

    for(int i=0; i<_numberOfAtoms; i++)
    {
        s<<"\t"<<_vcgtfNonNormalise[k].NumCenter()<<" "<<0<<endl;

        do{
            if(k==0)    //First shell
            {
                s<<" "<<_vcgtfNonNormalise[k].Ltype()<<"\t"<<_vcgtfNonNormalise[k].numberOfFunctions()<<"  ";
                s<<std::fixed<<setprecision(1)<<_vcgtfNonNormalise[k].FactorCoef()<<endl;

                for(int j=0; j<_vcgtfNonNormalise[k].numberOfFunctions(); j++)
                    s<<std::fixed<<setprecision(6)<<right<<setw(6)<<" "<<setw(15)<<_vcgtfNonNormalise[k].gtf()[j].get_exponent()<<"  "<<setw(15)<<_vcgtfNonNormalise[k].coefficients()[j]<<endl;

                k++;
            }

            else if(k+1<int(_vcgtfNonNormalise.size()))    //Other shell
            {
                if(_vcgtfNonNormalise[k].Ltype()==_vcgtfNonNormalise[k+1].Ltype() && _vcgtfNonNormalise[k].gtf()[0].get_exponent()==_vcgtfNonNormalise[k+1].gtf()[0].get_exponent())    //Other format
                {
                    lt=_vcgtfNonNormalise[k].gtf()[0].get_l()[0]+_vcgtfNonNormalise[k].gtf()[0].get_l()[1]+_vcgtfNonNormalise[k].gtf()[0].get_l()[2];

                    if(_vcgtfNonNormalise[k].Lformat()=="Cart")
                        m=(lt+1)*(lt+2)/2;
                    else
                        m=2*lt+1;

                    s<<" "<<_vcgtfNonNormalise[k].Ltype()<<"\t"<<_vcgtfNonNormalise[k].numberOfFunctions()<<"  ";
                    s<<std::fixed<<setprecision(1)<<_vcgtfNonNormalise[k].FactorCoef()<<endl;

                    for(int j=0; j<_vcgtfNonNormalise[k].numberOfFunctions(); j++)
                        s<<std::fixed<<setprecision(6)<<right<<setw(6)<<" "<<setw(15)<<_vcgtfNonNormalise[k].gtf()[j].get_exponent()<<"  "<<setw(15)<<_vcgtfNonNormalise[k].coefficients()[j]<<endl;

                    k+=m;
                }

                else if(_vcgtfNonNormalise[k].Ltype()==_vcgtfNonNormalise[k+1].Ltype())           //WFX
                {
                    lt=_vcgtfNonNormalise[k].gtf()[0].get_l()[0]+_vcgtfNonNormalise[k].gtf()[0].get_l()[1]+_vcgtfNonNormalise[k].gtf()[0].get_l()[2];

                    if(lt!=0)
                    {
                        m=(lt+1)*(lt+2)/2;
                        q=k;
                        save_alpha=_vcgtfNonNormalise[k].gtf()[0].get_exponent();

                        do{
                            s<<" "<<_vcgtfNonNormalise[q].Ltype()<<"\t"<<_vcgtfNonNormalise[q].numberOfFunctions()<<"  ";
                            s<<std::fixed<<setprecision(1)<<_vcgtfNonNormalise[q].FactorCoef()<<endl;

                            for(int j=0; j<_vcgtfNonNormalise[q].numberOfFunctions(); j++)
                                s<<std::fixed<<setprecision(6)<<right<<setw(6)<<" "<<setw(15)<<_vcgtfNonNormalise[q].gtf()[j].get_exponent()<<"  "<<setw(15)<<_vcgtfNonNormalise[q].coefficients()[j]<<endl;

                            q++;
                        }while(q+1<int(_vcgtfNonNormalise.size()) && _vcgtfNonNormalise[q].gtf()[0].get_exponent()!=save_alpha);
                        //q=q-k+1;        don't work for h2otest.wfx
                        q=q-k;
                        //k+=q*(m-1)+1;      don't work for h2otest.wfx
                        k+=q*m;
                    }

                    else
                    {
                        s<<" "<<_vcgtfNonNormalise[k].Ltype()<<"\t"<<_vcgtfNonNormalise[k].numberOfFunctions()<<"  ";
                        s<<std::fixed<<setprecision(1)<<_vcgtfNonNormalise[k].FactorCoef()<<endl;

                        for(int j=0; j<_vcgtfNonNormalise[k].numberOfFunctions(); j++)
                            s<<std::fixed<<setprecision(6)<<right<<setw(6)<<" "<<setw(15)<<_vcgtfNonNormalise[k].gtf()[j].get_exponent()<<"  "<<setw(15)<<_vcgtfNonNormalise[k].coefficients()[j]<<endl;

                        k++;
                    }
                }

                else               //Other case
                {
                    s<<" "<<_vcgtfNonNormalise[k].Ltype()<<"\t"<<_vcgtfNonNormalise[k].numberOfFunctions()<<"  ";
                    s<<std::fixed<<setprecision(1)<<_vcgtfNonNormalise[k].FactorCoef()<<endl;

                    for(int j=0; j<_vcgtfNonNormalise[k].numberOfFunctions(); j++)
                        s<<std::fixed<<setprecision(6)<<right<<setw(6)<<" "<<setw(15)<<_vcgtfNonNormalise[k].gtf()[j].get_exponent()<<"  "<<setw(15)<<_vcgtfNonNormalise[k].coefficients()[j]<<endl;

                    k++;
                }
            }
            else               //Last shell
            {
                s<<" "<<_vcgtfNonNormalise[k].Ltype()<<"\t"<<_vcgtfNonNormalise[k].numberOfFunctions()<<"  ";
                s<<std::fixed<<setprecision(1)<<_vcgtfNonNormalise[k].FactorCoef()<<endl;

                for(int j=0; j<_vcgtfNonNormalise[k].numberOfFunctions(); j++)
                    s<<std::fixed<<setprecision(6)<<right<<setw(6)<<" "<<setw(15)<<_vcgtfNonNormalise[k].gtf()[j].get_exponent()<<"  "<<setw(15)<<_vcgtfNonNormalise[k].coefficients()[j]<<endl;

                k++;
            }
        }while(k<int(_vcgtfNonNormalise.size()) && i+1==_vcgtfNonNormalise[k].NumCenter());
        s<<endl;
    }

    s<<endl;

    s<<"[MO]"<<endl;

    int n;
    if(_alphaAndBeta)
        n=2;
    else
        n=1;

    for(int i=0; i<2; i++)
        for(size_t j=0; j<_coefficients[i].size(); j++)
        {
            s<<setprecision(6)<<" Ene= "<<_orbitalEnergy[i][j]<<endl;
            if(i==0)
                s<<" Spin= Alpha"<<endl;
            else
                s<<" Spin= Beta"<<endl;
            s<<setprecision(6)<<" Occup= "<<_occupationNumber[i][j]/double(n)<<endl;
            s<<" Sym= unk"<<endl;

            for(size_t k=0; k<_coefficients[i][j].size(); k++)
            {
                s<<"\t"<<" "<<k+1<<"\t"<<"\t";
                s<<std::fixed<<setprecision(6)<<right<<setw(15)<<_coefficients[i][j][k]<<endl;
            }
        }

    s<<endl;
    s<<"[AO]"<<endl;
    s<<endl;

    s.close();
}

void Orbitals::Save_gab(string& tag)
{
    if(_mixte)
    {
        cout<<"Gabedit Format can't read mixte basis."<<endl;
        return;
    }

    if(int(_vcgtfNonNormalise.size())==_numberOfGtf)
    {
        cout<<"This option is nnot implemente."<<endl;
        return;
    }

    ofstream s;
    s.open(tag);

    s<<"[Gabedit Format] Cart"<<endl;

    s<<"[Atoms] AU"<<endl;
    for(int i=0; i<_numberOfAtoms; i++)
    {
        s<<_symbol[i]<<" "<<i+1<<" "<<_atomicNumbers[i];
        for(int j=i*3; j<(i+1)*3; j++)
            s<<std::fixed<<setprecision(6)<<right<<"  "<<setw(10)<<_coordinates[j];
        s<<endl;
    }

    s<<"[Basis]"<<endl;

    int lt,q,m,k=0;
    double save_alpha;

    for(int i=0; i<_numberOfAtoms; i++)
    {
        s<<"\t"<<_vcgtfNonNormalise[k].NumCenter()<<" "<<0<<endl;

        do{
            if(k==0)    //First shell
            {
                s<<" "<<_vcgtfNonNormalise[k].Ltype()<<"\t"<<_vcgtfNonNormalise[k].numberOfFunctions()<<"  ";
                s<<std::fixed<<setprecision(1)<<_vcgtfNonNormalise[k].FactorCoef()<<endl;

                for(int j=0; j<_vcgtfNonNormalise[k].numberOfFunctions(); j++)
                    s<<std::fixed<<setprecision(6)<<right<<setw(6)<<" "<<setw(15)<<_vcgtfNonNormalise[k].gtf()[j].get_exponent()<<"  "<<setw(15)<<_vcgtfNonNormalise[k].coefficients()[j]<<endl;

                k++;
            }

            else if(k+1<int(_vcgtfNonNormalise.size()))    //Other shell
            {
                if(_vcgtfNonNormalise[k].Ltype()==_vcgtfNonNormalise[k+1].Ltype() && _vcgtfNonNormalise[k].gtf()[0].get_exponent()==_vcgtfNonNormalise[k+1].gtf()[0].get_exponent())    //Other format
                {
                    lt=_vcgtfNonNormalise[k].gtf()[0].get_l()[0]+_vcgtfNonNormalise[k].gtf()[0].get_l()[1]+_vcgtfNonNormalise[k].gtf()[0].get_l()[2];

                    if(_vcgtfNonNormalise[k].Lformat()=="Cart")
                        m=(lt+1)*(lt+2)/2;
                    else
                        m=2*lt+1;

                    s<<" "<<_vcgtfNonNormalise[k].Ltype()<<"\t"<<_vcgtfNonNormalise[k].numberOfFunctions()<<"  ";
                    s<<std::fixed<<setprecision(1)<<_vcgtfNonNormalise[k].FactorCoef()<<endl;

                    for(int j=0; j<_vcgtfNonNormalise[k].numberOfFunctions(); j++)
                        s<<std::fixed<<setprecision(6)<<right<<setw(6)<<" "<<setw(15)<<_vcgtfNonNormalise[k].gtf()[j].get_exponent()<<"  "<<setw(15)<<_vcgtfNonNormalise[k].coefficients()[j]<<endl;

                    k+=m;
                }

                else if(_vcgtfNonNormalise[k].Ltype()==_vcgtfNonNormalise[k+1].Ltype())           //WFX
                {
                    lt=_vcgtfNonNormalise[k].gtf()[0].get_l()[0]+_vcgtfNonNormalise[k].gtf()[0].get_l()[1]+_vcgtfNonNormalise[k].gtf()[0].get_l()[2];

                    if(lt!=0)
                    {
                        m=(lt+1)*(lt+2)/2;
                        q=k;
                        save_alpha=_vcgtfNonNormalise[k].gtf()[0].get_exponent();

                        do{
                            s<<" "<<_vcgtfNonNormalise[q].Ltype()<<"\t"<<_vcgtfNonNormalise[q].numberOfFunctions()<<"  ";
                            s<<std::fixed<<setprecision(1)<<_vcgtfNonNormalise[q].FactorCoef()<<endl;

                            for(int j=0; j<_vcgtfNonNormalise[q].numberOfFunctions(); j++)
                                s<<std::fixed<<setprecision(6)<<right<<setw(6)<<" "<<setw(15)<<_vcgtfNonNormalise[q].gtf()[j].get_exponent()<<"  "<<setw(15)<<_vcgtfNonNormalise[q].coefficients()[j]<<endl;

                            q++;
                        }while(q+1<int(_vcgtfNonNormalise.size()) && _vcgtfNonNormalise[q].gtf()[0].get_exponent()!=save_alpha);
                        //q=q-k+1;        don't work for h2otest.wfx
                        q=q-k;
                        //k+=q*(m-1)+1;      don't work for h2otest.wfx
                        k+=q*m;
                    }

                    else
                    {
                        s<<" "<<_vcgtfNonNormalise[k].Ltype()<<"\t"<<_vcgtfNonNormalise[k].numberOfFunctions()<<"  ";
                        s<<std::fixed<<setprecision(1)<<_vcgtfNonNormalise[k].FactorCoef()<<endl;

                        for(int j=0; j<_vcgtfNonNormalise[k].numberOfFunctions(); j++)
                            s<<std::fixed<<setprecision(6)<<right<<setw(6)<<" "<<setw(15)<<_vcgtfNonNormalise[k].gtf()[j].get_exponent()<<"  "<<setw(15)<<_vcgtfNonNormalise[k].coefficients()[j]<<endl;

                        k++;
                    }
                }

                else               //Other case
                {
                    s<<" "<<_vcgtfNonNormalise[k].Ltype()<<"\t"<<_vcgtfNonNormalise[k].numberOfFunctions()<<"  ";
                    s<<std::fixed<<setprecision(1)<<_vcgtfNonNormalise[k].FactorCoef()<<endl;

                    for(int j=0; j<_vcgtfNonNormalise[k].numberOfFunctions(); j++)
                        s<<std::fixed<<setprecision(6)<<right<<setw(6)<<" "<<setw(15)<<_vcgtfNonNormalise[k].gtf()[j].get_exponent()<<"  "<<setw(15)<<_vcgtfNonNormalise[k].coefficients()[j]<<endl;

                    k++;
                }
            }
            else               //Last shell
            {
                s<<" "<<_vcgtfNonNormalise[k].Ltype()<<"\t"<<_vcgtfNonNormalise[k].numberOfFunctions()<<"  ";
                s<<std::fixed<<setprecision(1)<<_vcgtfNonNormalise[k].FactorCoef()<<endl;

                for(int j=0; j<_vcgtfNonNormalise[k].numberOfFunctions(); j++)
                    s<<std::fixed<<setprecision(6)<<right<<setw(6)<<" "<<setw(15)<<_vcgtfNonNormalise[k].gtf()[j].get_exponent()<<"  "<<setw(15)<<_vcgtfNonNormalise[k].coefficients()[j]<<endl;

                k++;
            }
        }while(k<int(_vcgtfNonNormalise.size()) && i+1==_vcgtfNonNormalise[k].NumCenter());
        s<<endl;
    }

    s<<endl;

    s<<"[MO]"<<endl;

    int n;
    if(_alphaAndBeta)
        n=2;
    else
        n=1;

    for(int i=0; i<2; i++)
        for(size_t j=0; j<_coefficients[i].size(); j++)
        {
            s<<setprecision(6)<<" Ene= "<<_orbitalEnergy[i][j]<<endl;
            if(i==0)
                s<<" Spin= Alpha"<<endl;
            else
                s<<" Spin= Beta"<<endl;
            s<<setprecision(6)<<" Occup= "<<_occupationNumber[i][j]/double(n)<<endl;
            s<<" Sym= unk"<<endl;

            for(size_t k=0; k<_coefficients[i][j].size(); k++)
            {
                s<<"\t"<<" "<<k+1<<"\t"<<"\t";
                s<<std::fixed<<setprecision(6)<<right<<setw(15)<<_coefficients[i][j][k]<<endl;
            }
        }

    s<<endl;
    s<<"[AO]"<<endl;
    s<<endl;

    s.close();
}

void Orbitals::Sorting()
{
    int k=0,q=0,pos,lt,m=0;

    if(_numberOfGtf==int(_vcgtf.size()))
    {
        for(int i=0; i<_numberOfAtoms; i++)
        {
            do{
                if(k+1<int(_vcgtf.size()))
                {
                    if((_vcgtf[k].Ltype()=="s" || _vcgtf[k].Ltype()=="S") || (_vcgtf[k+1].Ltype()=="s" || _vcgtf[k+1].Ltype()=="S"))
                        q=0;

                    else if(_vcgtf[k].Ltype()==_vcgtf[k+1].Ltype())
                    {
                        lt=_vcgtf[k].gtf()[0].get_l()[0]+_vcgtf[k].gtf()[0].get_l()[1]+_vcgtf[k].gtf()[0].get_l()[2];
                        m=(lt+1)*(lt+2)/2;
                        q=k;

                        do{
                            q++;
                        }while(_vcgtf[q].Ltype()==_vcgtf[k].Ltype());

                        q=q-k;
                        k+=q+1;
                    }

                    if(q>m)
                    {
                        pos=k-q-1;
                        q=pos;

                        for(int ind=0; ind<m-1; ind++)
                        {
                            q++;
                            swap(_vcgtf[q], _vcgtf[q+m-1]);
                            q+=m;
                        }

                        q=pos+m-1;

                        swap(_vcgtf[q], _vcgtf[q+m+1]);

                        q=0;
                        k++;
                    }

                    else
                    {
                        k++;
                        continue;
                    }
                }
                else
                {
                    k++;
                    continue;
                }
            }while(k<int(_vcgtf.size()) && i+1==_vcgtf[k].NumCenter());
        }
        DenormaliseAllBasis();
    }
}
