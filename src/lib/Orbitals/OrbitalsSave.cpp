#include<iostream>
#include<iomanip>
#include <Orbitals/Orbitals.h>
#include <Utils/LM.h>

using namespace std;


void Orbitals::Save(string& tag)
{
	if(tag.find(".wfx")!=string::npos)
		Save_wfx(tag);
	else if(tag.find(".molden")!=string::npos)
		Save_molden(tag);
	else if(tag.find(".gab")!=string::npos)
		Save_gab(tag);
	else
	{
		cout<<"Format not recognize, please choose a valide format"<<endl;
		exit(1);
	}
}

void Orbitals::Save_wfx(string& tag)
{
	int n, nMO;
	ofstream s;
	s.open(tag);

	s<<"<Title>"<<endl;
	s<<" Input file generated by cdftt..."<<endl;
	s<<"</Title>"<<endl;

	s<<"<Keywords>"<<endl;
	s<<" GTO"<<endl;
	s<<"</Keywords>"<<endl;

	s<<"<Number of Nuclei>"<<endl;
	s<<" "<<_number_of_atoms<<endl;
	s<<"</Number of Nuclei>"<<endl;

	s<<"<Number of Occupied Molecular Orbitals>"<<endl;
	if(!_alpha_and_beta)
		nMO=_numberOfMo*2;
	else
		nMO=_numberOfMo;
	s<<" "<<nMO<<endl;
	s<<"</Number of Occupied Molecular Orbitals>"<<endl;

	s<<"<Number of Perturbations>"<<endl;
	s<<" 0"<<endl;
	s<<"</Number of Perturbations>"<<endl;

	s<<"<Net Charge>"<<endl;
	s<<" 0"<<endl;
	s<<"</Net Charge>"<<endl;

	s<<"<Number of Electrons>"<<endl;
	s<<" "<<_number_of_alpha_electrons+_number_of_beta_electrons<<endl;
	s<<"</Number of Electrons>"<<endl;

	s<<"<Number of Alpha Electrons>"<<endl;
	s<<" "<<_number_of_alpha_electrons<<endl;
	s<<"</Number of Alpha Electrons>"<<endl;

	s<<"<Number of Beta Electrons>"<<endl;
	s<<" "<<_number_of_beta_electrons<<endl;
	s<<"</Number of Beta Electrons>"<<endl;

	s<<"<Nuclear Names>"<<endl;
	for(int i=0; i<_number_of_atoms; i++)
		s<<" "<<_symbol[i]<<i+1<<endl;
	s<<"</Nuclear Names>"<<endl;

	s<<"<Atomic Numbers>"<<endl;
	for(int i=0; i<_number_of_atoms; i++)
		s<<" "<<_atomic_numbers[i]<<endl;
	s<<"</Atomic Numbers>"<<endl;	

	s<<"<Nuclear Charges>"<<endl;
	for(int i=0; i<_number_of_atoms; i++)
		s<<right<<scientific<<setprecision(12)<<" "<<setw(20)<<double(_atomic_numbers[i])<<endl;
	s<<"</Nuclear Charges>"<<endl;

	s<<"<Nuclear Cartesian Coordinates>"<<endl;
	for(int i=0; i<_number_of_atoms; i++)
	{
		for(int j=i*3; j<(i+1)*3; j++)
			s<<right<<scientific<<setprecision(12)<<" "<<setw(20)<<_coordinates[j];
		s<<endl;
	}
	s<<"</Nuclear Cartesian Coordinates>"<<endl;

	s<<"<Number of Primitives>"<<endl;
	s<<" "<<_number_of_gtf<<endl;
	s<<"</Number of Primitives>"<<endl;

	s<<"<Primitive Centers>"<<endl;
	for(int i=0; i<_number_of_gtf; i++)
	{
		s<<"\t"<<_primitive_centers[i];
		if((i+1)%5==0)
			s<<endl;
	}
	s<<endl;
	s<<"</Primitive Centers>"<<endl;

	n=0;
	s<<"<Primitive Types>"<<endl;
	for(size_t i=0; i<_vcgtf.size(); i++)
		for(int j=0; j<_vcgtf[i].numberOfFunctions(); j++)
		{
			s<<"\t"<<getwfxType(_vcgtf[i].gtf()[j].l());
			if((n+1)%5==0)
				s<<endl;
			n++;
		}
	s<<endl;
	s<<"</Primitive Types>"<<endl;

	n=0;
	s<<"<Primitive Exponents>"<<endl;
	for(size_t i=0; i<_vcgtf.size(); i++)
		for(int j=0; j<_vcgtf[i].numberOfFunctions(); j++)
		{
			s<<right<<scientific<<setprecision(12)<<"\t"<<setw(20)<<_vcgtf[i].gtf()[j].exposant();
			if((n+1)%5==0)
				s<<endl;
			n++;
		}
	s<<endl;
	s<<"</Primitive Exponents>"<<endl;

	int m;

	if(_alpha_and_beta)
		m=1;
	else
		m=2;

	s<<"<Molecular Orbital Occupation Numbers>"<<endl;
	for(int i=0; i<m; i++)
		for(int j=0; j<_numberOfMo; j++)
			s<<" "<<_occupation_number[i][j]<<endl;
	s<<"</Molecular Orbital Occupation Numbers>"<<endl;

	s<<"<Molecular Orbital Energies>"<<endl;
	for(int i=0; i<m; i++)
		for(size_t j=0; j<_orbital_energy[i].size(); j++)
			s<<right<<scientific<<setprecision(12)<<" "<<setw(20)<<_orbital_energy[i][j]<<endl;
	s<<"</Molecular Orbital Energies>"<<endl;

	s<<"<Molecular Orbital Spin Types>"<<endl;
	if(m==1)
		for(int i=0; i<_numberOfMo; i++)
			s<<" "<<"Alpha and Beta"<<endl;
	else
	{
		for(size_t i=0; i<_orbital_energy[0].size(); i++)
			s<<" "<<"Alpha"<<endl;
		for(size_t i=0; i<_orbital_energy[1].size(); i++)
			s<<" "<<"Beta"<<endl;
	}
	s<<"</Molecular Orbital Spin Types>"<<endl;

	s<<"<Molecular Orbital Primitive Coefficients>"<<endl;
	int a=0,b=0;
	for(int i=0; i<m; i++)
		for(int j=0; j<_numberOfMo; j++)
		{
			a++;
			s<<"<MO Number>"<<endl;
			s<<" "<<a<<endl;
			s<<"</MO Number>"<<endl;
		
			for(size_t k=0; k<_vcgtf.size(); k++)
				for(int l=0; l<_vcgtf[k].numberOfFunctions(); l++)
				{
					s<<right<<scientific<<setprecision(12)<<" "<<setw(20)<<_vcgtf[k].coefficients()[l]*_vcgtf[k].gtf()[l].coefficient()*_coefficients[i][j][k];

					if((b+1)%4==0)
						s<<endl;
					b++;
				}

			if(b%4!=0)
				s<<endl;
		}
	s<<"</Molecular Orbital Primitive Coefficients>"<<endl;

	s<<"<Energy = T + Vne + Vee + Vnn>"<<endl;
	s<<" "<<_energy<<endl;
	s<<"</Energy = T + Vne + Vee + Vnn>"<<endl;

	s<<"<Virial Ratio (-V/T)>"<<endl;
	s<<" "<<scientific<<setprecision(12)<<2<<endl;
	s<<"</Virial Ratio (-V/T)>"<<endl;

	s.close();
}
															// Moldengab faire attention au format sphe/cart !!!!
void Orbitals::Save_molden(string& tag)	
{
	ofstream s;
	s.open(tag);

	s<<"[Molden Format]"<<endl;

	s<<"[Atoms] AU"<<endl;
	for(int i=0; i<_number_of_atoms; i++)
	{
		s<<_symbol[i]<<"\t"<<i+1<<"\t"<<_atomic_numbers[i];
		for(int j=i*3; j<(i+1)*3; j++)
			s<<right<<"\t"<<"\t"<<setprecision(6)<<setw(10)<<_coordinates[j];
		s<<endl;
	}

	s<<"[GTO]"<<endl;

	int lt,q,m,k=0;
	double save_alpha;

	for(int i=0; i<_number_of_atoms; i++)
	{
		s<<"\t"<<_vcgtf_non_normalise[k].NumCenter()<<" "<<0<<endl;

		do{
			if(k==0)	//First shell
			{
				s<<" "<<_vcgtf_non_normalise[k].Ltype()<<"\t"<<_vcgtf_non_normalise[k].numberOfFunctions()<<"  "<<setprecision(6)<<_vcgtf_non_normalise[k].FactorCoef()<<endl;

				for(int j=0; j<_vcgtf_non_normalise[k].numberOfFunctions(); j++)
					s<<right<<setw(6)<<" "<<setprecision(6)<<setw(10)<<_vcgtf_non_normalise[k].gtf()[j].exposant()<<"  "<<setprecision(6)<<setw(10)<<_vcgtf_non_normalise[k].coefficients()[j]<<endl;

				k++;
			}

			else if(k+1<int(_vcgtf_non_normalise.size()))	//Other shell
			{


				if(_vcgtf_non_normalise[k].Ltype()==_vcgtf_non_normalise[k+1].Ltype() && _vcgtf_non_normalise[k].gtf()[0].exposant()==_vcgtf_non_normalise[k+1].gtf()[0].exposant())	//Other format
				{
					lt=_vcgtf_non_normalise[k].gtf()[0].l()[0]+_vcgtf_non_normalise[k].gtf()[0].l()[1]+_vcgtf_non_normalise[k].gtf()[0].l()[2];
					m=(lt+1)*(lt+2)/2;

					s<<" "<<_vcgtf_non_normalise[k].Ltype()<<"\t"<<_vcgtf_non_normalise[k].numberOfFunctions()<<"  "<<setprecision(6)<<_vcgtf_non_normalise[k].FactorCoef()<<endl;

					for(int j=0; j<_vcgtf_non_normalise[k].numberOfFunctions(); j++)
						s<<right<<setw(6)<<" "<<setprecision(6)<<setw(10)<<_vcgtf_non_normalise[k].gtf()[j].exposant()<<"  "<<setprecision(6)<<setw(10)<<_vcgtf_non_normalise[k].coefficients()[j]<<endl;

					k+=m;
				}

				else if(_vcgtf_non_normalise[k].Ltype()==_vcgtf_non_normalise[k+1].Ltype())   		//WFX
				{
					lt=_vcgtf_non_normalise[k].gtf()[0].l()[0]+_vcgtf_non_normalise[k].gtf()[0].l()[1]+_vcgtf_non_normalise[k].gtf()[0].l()[2];

					if(lt!=0)
					{
						m=(lt+1)*(lt+2)/2;
						q=k;
						save_alpha=_vcgtf_non_normalise[k].gtf()[0].exposant();

						do{
							s<<" "<<_vcgtf_non_normalise[q].Ltype()<<"\t"<<_vcgtf_non_normalise[q].numberOfFunctions()<<"  "<<setprecision(6)<<_vcgtf_non_normalise[q].FactorCoef()<<endl;

							for(int j=0; j<_vcgtf_non_normalise[q].numberOfFunctions(); j++)
								s<<right<<setw(6)<<" "<<setprecision(6)<<setw(10)<<_vcgtf_non_normalise[q].gtf()[j].exposant()<<"  "<<setprecision(6)<<setw(10)<<_vcgtf_non_normalise[q].coefficients()[j]<<endl;

							q++;
						}while(_vcgtf_non_normalise[q].gtf()[0].exposant()!=save_alpha);
						q=q-k+1;
						k+=q*(m-1)+1;
					}

					else
					{
						s<<" "<<_vcgtf_non_normalise[k].Ltype()<<"\t"<<_vcgtf_non_normalise[k].numberOfFunctions()<<"  "<<setprecision(6)<<_vcgtf_non_normalise[k].FactorCoef()<<endl;

						for(int j=0; j<_vcgtf_non_normalise[k].numberOfFunctions(); j++)
							s<<right<<setw(6)<<" "<<setprecision(6)<<setw(10)<<_vcgtf_non_normalise[k].gtf()[j].exposant()<<"  "<<setprecision(6)<<setw(10)<<_vcgtf_non_normalise[k].coefficients()[j]<<endl;

						k++;
					}
				}

				else   			//Other case
				{
					s<<" "<<_vcgtf_non_normalise[k].Ltype()<<"\t"<<_vcgtf_non_normalise[k].numberOfFunctions()<<"  "<<setprecision(6)<<_vcgtf_non_normalise[k].FactorCoef()<<endl;

					for(int j=0; j<_vcgtf_non_normalise[k].numberOfFunctions(); j++)
						s<<right<<setw(6)<<" "<<setprecision(6)<<setw(10)<<_vcgtf_non_normalise[k].gtf()[j].exposant()<<"  "<<setprecision(6)<<setw(10)<<_vcgtf_non_normalise[k].coefficients()[j]<<endl;

					k++;
				}
			}
			else   			//Last shell
			{
				s<<" "<<_vcgtf_non_normalise[k].Ltype()<<"\t"<<_vcgtf_non_normalise[k].numberOfFunctions()<<"  "<<setprecision(6)<<_vcgtf_non_normalise[k].FactorCoef()<<endl;

				for(int j=0; j<_vcgtf_non_normalise[k].numberOfFunctions(); j++)
					s<<right<<setw(6)<<" "<<setprecision(6)<<setw(10)<<_vcgtf_non_normalise[k].gtf()[j].exposant()<<"  "<<setprecision(6)<<setw(10)<<_vcgtf_non_normalise[k].coefficients()[j]<<endl;

				k++;
			}

			
		}while(k<int(_vcgtf_non_normalise.size()) && i+1==_vcgtf_non_normalise[k].NumCenter());
		s<<endl;
	}

	s<<endl;
	s<<endl;

	s<<"[MO]"<<endl;

	int n;
	if(_alpha_and_beta)
		n=2;
	else
		n=1;

	for(int i=0; i<2; i++)
		for(size_t j=0; j<_coefficients[i].size(); j++)
		{
			s<<" Ene= "<<setprecision(6)<<_orbital_energy[i][j]<<endl;
			if(i==0)
				s<<" Spin= Alpha"<<endl;
			else
				s<<" Spin= Beta"<<endl;
			s<<" Occup= "<<setprecision(6)<<_occupation_number[i][j]/double(n)<<endl;
			s<<" Sym= unk"<<endl;

			for(size_t k=0; k<_coefficients[i][j].size(); k++)
				s<<"\t"<<" "<<k+1<<"\t"<<"\t"<<setprecision(6)<<_coefficients[i][j][k]<<endl;
		}

	s<<endl;
	s<<"[AO]"<<endl;
	s<<endl;

	s.close();
}

void Orbitals::Save_gab(string& tag)
{
	ofstream s;
	s.open(tag);

	s<<"[Gabedit Format]"<<endl;

	s<<"[Atoms] AU"<<endl;
	for(int i=0; i<_number_of_atoms; i++)
	{
		s<<_symbol[i]<<"\t"<<i+1<<"\t"<<_atomic_numbers[i];
		for(int j=i*3; j<(i+1)*3; j++)
			s<<scientific<<setprecision(10)<<"\t"<<"\t"<<_coordinates[j];
		s<<endl;
	}

	s<<"[Basis]"<<endl;

	int k=0;
	for(int i=0; i<_number_of_atoms; i++)
	{
		s<<"\t"<<_vcgtf_non_normalise[k].NumCenter()<<" "<<0<<endl;
		do{
			s<<" "<<_vcgtf_non_normalise[k].Ltype()<<"\t"<<_vcgtf_non_normalise[k].numberOfFunctions()<<"  "<<_vcgtf[k].FactorCoef()<<endl;
			for(int j=0; j<_vcgtf_non_normalise[k].numberOfFunctions(); j++)
				s<<scientific<<setprecision(10)<<"  "<<_vcgtf_non_normalise[k].gtf()[j].exposant()<<"  "<<_vcgtf[k].coefficients()[j]<<endl;
			k++;
		}while(i+1==_vcgtf[k].NumCenter());
		s<<endl;
	}

	s<<endl;
	s<<endl;

	s<<"[MO]"<<endl;

	int n;
	if(_alpha_and_beta)
		n=1;
	else
		n=2;

	for(int i=0; i<n; i++)
		for(size_t j=0; j<_coefficients[i].size(); j++)
		{
			s<<scientific<<setprecision(10)<<" Ene= "<<_orbital_energy[i][j]<<endl;
			if(i==0)
				s<<" Spin= Alpha"<<endl;
			else
				s<<" Spin= Beta"<<endl;
			s<<scientific<<setprecision(10)<<" Occup= "<<_occupation_number[i][j]<<endl;
			s<<" Sym= unk"<<endl;

			for(size_t k=0; k<_coefficients[i][j].size(); k++)
				s<<scientific<<setprecision(10)<<"\t"<<" "<<k+1<<"\t"<<_coefficients[i][j][k]<<endl;
		}

	s<<endl;
	s<<"[AO]"<<endl;
	s<<endl;
	s<<endl;

	s.close();
}